<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Hunt & Fish — Single File (Fixed Controls & Land/Water)</title>
<style>
  :root{--panel:rgba(6,10,20,0.78);--accent:#6fe8ff}
  html,body{height:100%;margin:0;background:#071226;color:#eaf6ff;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;overflow:hidden}
  #game{width:100vw;height:100vh;position:relative}
  canvas{display:block}

  /* HUD */
  .hud{position:absolute;z-index:60;pointer-events:none}
  #topLeft{left:12px;top:12px}
  #topRight{right:12px;top:12px;text-align:right}
  #bottomLeft{left:12px;bottom:12px}
  #bottomRight{right:12px;bottom:12px}
  .panel{background:var(--panel);padding:10px 12px;border-radius:12px;font-size:13px;min-width:220px;box-shadow:0 6px 30px rgba(0,0,0,0.6)}
  .label{color:var(--accent);font-weight:700}
  #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;pointer-events:none;z-index:70}
  #crosshair:before,#crosshair:after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:12px;background:rgba(255,255,255,0.9)}
  #crosshair:before{transform:translate(-50%,-50%) rotate(90deg)}
  .meter{height:10px;background:rgba(255,255,255,0.08);border-radius:6px;overflow:hidden;margin-top:6px}
  .meter>i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#2fa8ff);width:50%}
  #controls{font-size:13px;color:#cde8ff}
  #message{position:absolute;left:50%;top:20%;transform:translateX(-50%);z-index:80;display:none;padding:12px 16px;background:rgba(0,0,0,0.72);border-radius:10px;font-size:16px}
  @media(max-width:720px){.panel{min-width:160px;font-size:12px}}
</style>
</head>
<body>
<div id="game"></div>

<!-- HUD -->
<div class="hud" id="topLeft"><div class="panel">
  <div><span class="label">Hunt & Fish</span> • Mode: <span id="mode">Explore</span></div>
  <div style="margin-top:6px">Zone: <b id="zone">Land</b> • Time: <b id="timeOfDay">Day</b></div>
  <div style="margin-top:6px">Health: <span id="health">100</span> • Stamina: <span id="stamina">100</span></div>
  <div style="margin-top:6px">Weapon: <span id="weapon">Rifle</span> • Rod: <span id="rod">Basic</span></div>
  <div class="meter"><i id="staminaBar" style="width:100%"></i></div>
</div></div>

<div class="hud" id="topRight"><div class="panel">
  <div>Score: <b id="score">0</b></div>
  <div style="margin-top:6px">Ammo: <span id="ammo">12</span> • Lures: <span id="lures">5</span></div>
  <div style="margin-top:6px">High Score: <b id="highScore">0</b></div>
</div></div>

<div class="hud" id="bottomLeft"><div class="panel" id="controls">
  Controls: Click to lock pointer • WASD move • Mouse look • Shift sprint • Space jump<br>
  Left click: Fire/Cast/Interact • Hold LMB to charge cast • R: change lure • B: board boat • C: camera
</div></div>

<div id="crosshair"></div>
<div id="message"></div>

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* ====================================================
   Single-file Hunt + Fish (fixed movement/pointer/water)
   - Movement is camera-relative (W forward, S back, A left, D right)
   - Pointer lock robust: click anywhere to lock; shows message on error
   - Distinct terrain: grass plane, sand shoreline ring, circular water
   - Animals (deer, ducks) with wandering + fleeing AI
   - Fishing near water (detect by distance to water)
   - Hunting via hitscan rifle (left click)
   - Optimized for MacBook Air: low-poly, limited counts, efficient loops
   ==================================================== */

/* ---------- Config & Helpers ---------- */
const WORLD = { size: 900, waterRadius: 160, waterY: -1.2 };
function rand(a,b){ return a + Math.random()*(b-a); }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function format(n){ return Math.round(n*100)/100; }

/* ---------- Audio helper (tiny cues) ---------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function beep(freq=440, dur=0.08, vol=0.04, type='sine'){
  const o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* ---------- Scene ---------- */
const container = document.getElementById('game');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x9bd0ff, 0.0007);

const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 3000);
camera.position.set(0, 2.0, 8);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

const ambient = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xfff2d6, 0.9);
sun.position.set(200,400,-150);
scene.add(sun);

/* ---------- Terrain: grass plane, sand ring, circular water ---------- */
/* grass plane */
const grassMat = new THREE.MeshLambertMaterial({ color: 0x2e8b57 });
const grass = new THREE.Mesh(new THREE.PlaneGeometry(WORLD.size, WORLD.size, 8, 8), grassMat);
grass.rotation.x = -Math.PI/2;
scene.add(grass);

/* sand shoreline ring (around center water) */
const sandMat = new THREE.MeshLambertMaterial({ color: 0xded1a3 });
const shoreInner = WORLD.waterRadius + 6;
const shoreOuter = WORLD.waterRadius + 18;
const shoreGeo = new THREE.RingGeometry(shoreInner, shoreOuter, 64);
const shore = new THREE.Mesh(shoreGeo, sandMat);
shore.rotation.x = -Math.PI/2;
scene.add(shore);

/* circular water in center */
const waterMat = new THREE.MeshPhongMaterial({ color: 0x1e90ff, shininess: 30, transparent: true, opacity: 0.9 });
const waterGeo = new THREE.CircleGeometry(WORLD.waterRadius, 128);
const lake = new THREE.Mesh(waterGeo, waterMat);
lake.rotation.x = -Math.PI/2;
lake.position.y = WORLD.waterY;
scene.add(lake);

/* subtle wave normal via small vertex displacement (fast) */
(function addWaterRipple(){
  const pos = waterGeo.attributes.position;
  for(let i=0;i<pos.count;i++){
    const x = pos.getX(i), z = pos.getY ? pos.getY(i) : pos.getZ(i); // fallback
    pos.setZ ? pos.setZ(i, Math.sin(x*0.02)*0.02) : null;
  }
  if(waterGeo.attributes.position) waterGeo.computeVertexNormals();
})();

/* ---------- Simple decor: low-poly trees and rocks ---------- */
const decor = new THREE.Group(); scene.add(decor);
function spawnDecor(count=140){
  for(let i=0;i<count;i++){
    const x = rand(-WORLD.size/2, WORLD.size/2);
    const z = rand(-WORLD.size/2, WORLD.size/2);
    const distCenter = Math.hypot(x, z);
    // avoid putting trees in the water
    if(distCenter < WORLD.waterRadius + 20) continue;
    if(Math.random() < 0.72){
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.12,0.18,1.6), new THREE.MeshLambertMaterial({color: 0x7b4c2b}));
      trunk.position.set(x, 0.9, z);
      const leaves = new THREE.Mesh(new THREE.ConeGeometry(0.9 + Math.random()*0.8, 2.6, 6), new THREE.MeshLambertMaterial({ color: 0x0f6a2f }));
      leaves.position.set(x, 2.3, z);
      decor.add(trunk); decor.add(leaves);
    } else {
      const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.5 + Math.random()*0.9), new THREE.MeshLambertMaterial({ color: 0x666666 }));
      rock.position.set(x, 0.4, z); rock.rotation.set(Math.random(), Math.random(), Math.random());
      decor.add(rock);
    }
  }
}
spawnDecor();

/* ---------- Player & Controls (camera-relative movement) ---------- */
const player = {
  pos: new THREE.Vector3(60, 0, 20),
  height: 1.8,
  stamina: 100,
  health: 100,
  cameraMode: 0 // 0 first person, 1 short TP, 2 mid TP
};
let yaw = 0, pitch = 0;
const keys = {}, pointer = {locked:false};

/* pointer lock setup (robust) */
function enablePointerLock(){
  const el = document.body;
  el.requestPointerLock = el.requestPointerLock || el.mozRequestPointerLock || el.webkitRequestPointerLock;
  if(!el.requestPointerLock){
    showMessage('Pointer Lock not supported in this browser.');
    return;
  }
  el.requestPointerLock();
}
document.body.addEventListener('click', ()=> {
  // resume audio if suspended (iOS/macOS resume requirement)
  if(audioCtx.state === 'suspended') audioCtx.resume().catch(()=>{});
  enablePointerLock();
});
document.addEventListener('pointerlockchange', ()=> {
  pointer.locked = (document.pointerLockElement === document.body);
  if(!pointer.locked) showMessage('Pointer unlocked. Click to lock and play.');
});
document.addEventListener('pointerlockerror', ()=> {
  showMessage('Pointer lock failed. Try clicking again.');
});

/* mouse look */
document.addEventListener('mousemove', e => {
  if(!pointer.locked) return;
  yaw -= e.movementX * 0.0022;
  pitch -= e.movementY * 0.0022;
  pitch = clamp(pitch, -Math.PI/2 + 0.05, Math.PI/2 - 0.05);
});

/* keyboard */
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);

/* movement update: camera-relative */
function updatePlayer(dt){
  // direction vectors using yaw
  const forward = new THREE.Vector3(Math.sin(yaw), 0, Math.cos(yaw));
  const right = new THREE.Vector3(forward.z, 0, -forward.x);
  const mv = new THREE.Vector3();
  if(keys['KeyW']) mv.add(forward);
  if(keys['KeyS']) mv.sub(forward);
  if(keys['KeyA']) mv.sub(right);
  if(keys['KeyD']) mv.add(right);
  if(mv.lengthSq() > 0) mv.normalize();

  const sprint = keys['ShiftLeft'] && player.stamina > 6;
  const speed = (player.inBoat ? 5.0 : (sprint ? 5.0 : 2.2));
  if(sprint && !player.inBoat) player.stamina = clamp(player.stamina - dt * 16, 0, 100);
  else player.stamina = clamp(player.stamina + dt * 7, 0, 100);

  player.pos.addScaledVector(mv, speed * dt * 3.5);
  // clamp world
  player.pos.x = clamp(player.pos.x, -WORLD.size/2 + 4, WORLD.size/2 - 4);
  player.pos.z = clamp(player.pos.z, -WORLD.size/2 + 4, WORLD.size/2 - 4);

  // height follows ground (simple)
  const groundY = 0; // flat ground for simplicity
  player.pos.y = groundY + player.height;

  // camera position: FP or TP based on cameraMode
  const camBase = player.pos.clone().add(new THREE.Vector3(0, player.height + 0.2, 0));
  const behindDist = player.cameraMode === 0 ? 0 : (player.cameraMode === 1 ? 6 : 12);
  const behind = new THREE.Vector3(0, 0, behindDist).applyEuler(new THREE.Euler(0, yaw, 0));
  camera.position.copy(camBase).add(behind);
  camera.lookAt(camBase);
}

/* ---------- Animals (deer + ducks) with simple AI ---------- */
const animalTypes = [
  {name:'Deer', size:1.6, color:0xc4a176, speed:1.8, hp:60, points:60, avoidWater:true},
  {name:'Duck', size:0.6, color:0xffd27a, speed:1.4, hp:6, points:12, avoidWater:false}
];

const animals = [];
function spawnAnimals(count = 16){
  for(let i=0;i<count;i++){
    const type = pick(animalTypes);
    let x,z;
    // spawn animals mostly on land near shoreline and plains
    do{ x = rand(-WORLD.size/2, WORLD.size/2); z = rand(-WORLD.size/2, WORLD.size/2); } while(Math.hypot(x,z) < WORLD.waterRadius + 8 && type.avoidWater);
    const y = 0.2;
    const g = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(type.size, type.size*0.5, type.size*0.5), new THREE.MeshStandardMaterial({color:type.color}));
    body.position.y = type.size*0.25;
    g.add(body); g.position.set(x,y,z);
    g.userData = {type, state:'wander', target:null, hp:type.hp};
    animals.push(g); scene.add(g);
  }
}
spawnAnimals();

function updateAnimals(dt){
  for(const a of animals){
    if(a.userData.state === 'dead') continue;
    if(!a.userData.target || Math.random() < 0.02){
      // choose a random target on land (avoid water for some types)
      let tx, tz;
      do{ tx = a.position.x + rand(-18,18); tz = a.position.z + rand(-18,18); } while(Math.hypot(tx,tz) < WORLD.waterRadius - 6 && a.userData.type.avoidWater);
      a.userData.target = new THREE.Vector3(tx, 0, tz);
    }
    const dir = new THREE.Vector3().subVectors(a.userData.target, a.position);
    if(dir.length() > 1.2){
      dir.normalize();
      a.position.addScaledVector(dir, a.userData.type.speed * dt * (a.userData.state === 'alert' ? 2.0 : 0.7));
      a.lookAt(a.userData.target.x, a.position.y, a.userData.target.z);
    } else {
      if(Math.random() < 0.01) a.userData.target = null;
    }
    // detection of player noise (simple): if player sprinting within range
    const d = a.position.distanceTo(player.pos);
    const playerNoise = (keys['ShiftLeft'] ? 1.0 : 0.15);
    if(d < 20 * (1 + playerNoise) && Math.random() < 0.005 * (1 + playerNoise*6)){
      a.userData.state = 'alert';
      const away = new THREE.Vector3().subVectors(a.position, player.pos).normalize();
      a.userData.target = a.position.clone().add(away.multiplyScalar(30));
    }
  }
}

/* ---------- Hunting: simple hitscan rifle ---------- */
let ammo = 12;
document.getElementById('ammo').textContent = ammo;
function fireRifle(){
  const now = performance.now() / 1000;
  if(ammo <= 0){ beep(160, 0.14, 0.02, 'triangle'); return; }
  ammo--; document.getElementById('ammo').textContent = ammo;
  beep(1200,0.05,0.06,'square');
  const origin = camera.position.clone();
  const dir = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation).normalize();
  // check animals quickly
  let hit = null, best = Infinity;
  for(const a of animals){
    if(a.userData.state === 'dead') continue;
    const toA = new THREE.Vector3().subVectors(a.position, origin);
    const proj = toA.dot(dir);
    if(proj > 0 && proj < 500){
      const closest = origin.clone().add(dir.clone().multiplyScalar(proj));
      const d = closest.distanceTo(a.position);
      if(d < 1.8 && proj < best){ best = proj; hit = a; }
    }
  }
  if(hit){
    hit.userData.hp -= 80;
    hit.userData.state = 'alert';
    if(hit.userData.hp <= 0){
      hit.userData.state = 'dead';
      scene.remove(hit);
      const idx = animals.indexOf(hit); if(idx>=0) animals.splice(idx,1);
      const pts = hit.userData.type.points;
      score += pts; updateHUD();
      showMessage(`Down: ${hit.userData.type.name} +${pts}`);
      // respawn after delay
      setTimeout(()=> spawnAnimals(1), 7000);
    } else {
      showMessage(`${hit.userData.type.name} wounded!`);
    }
  } else {
    // miss tracer (very short lived)
  }
}

/* ---------- Fishing: detect near water, cast bobber, bite, reel ---------- */
const fishSpecies = [
  {name:'Trout',points:20},
  {name:'Bass',points:30},
  {name:'Carp',points:15},
  {name:'Salmon',points:45},
  {name:'Tuna',points:120}
];

let mode = 'explore'; // explore | fishing | hunting
let castCharging = false, castPower = 0;
let bobber = null, fishHooked = null, reeling = false;

function isNearWater(){
  const distToCenter = Math.hypot(player.pos.x, player.pos.z);
  return distToCenter <= (WORLD.waterRadius + 8);
}

document.addEventListener('mousedown', e => {
  if(e.button !== 0) return;
  if(!pointer.locked) return;
  // context-sensitive
  if(isNearWater() && !bobber && !reeling){
    // start charging cast
    castCharging = true; castPower = 0;
    mode = 'fishing'; updateHUD();
  } else {
    // attempt to fire rifle if not fishing
    if(!isNearWater()) fireRifle();
  }
});
document.addEventListener('mouseup', e => {
  if(e.button !== 0) return;
  if(castCharging){ doCast(); castCharging = false; }
});

function doCast(){
  if(!isNearWater()) return;
  const dir = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation).normalize();
  const speed = 8 + 18 * (castPower / 100);
  const vel = dir.clone().multiplyScalar(speed);
  // spawn bobber
  const b = new THREE.Mesh(new THREE.SphereGeometry(0.16, 8, 8), new THREE.MeshStandardMaterial({color:0xff4d6d}));
  b.position.copy(camera.position).add(new THREE.Vector3(0,-0.2,0)).add(dir.clone().multiplyScalar(1.2));
  scene.add(b);
  bobber = {mesh: b, vel, landed:false, timeInWater:0};
  beep(880, 0.06, 0.04);
  mode = 'fishing'; updateHUD();
}

function updateBobber(dt){
  if(!bobber) return;
  if(!bobber.landed){
    bobber.vel.y -= 9.8 * dt * 0.6;
    bobber.mesh.position.addScaledVector(bobber.vel, dt);
    if(bobber.mesh.position.y <= WORLD.waterY + 0.05){
      bobber.landed = true; bobber.mesh.position.y = WORLD.waterY + 0.05; bobber.timeInWater = 0; beep(420,0.06,0.03);
    }
  } else {
    bobber.timeInWater += dt;
    // drift a little
    bobber.mesh.position.x += Math.sin(perfTime*0.001) * 0.005;
    bobber.mesh.position.z += Math.cos(perfTime*0.001) * 0.005;
    // chance for fish bite
    if(!fishHooked && bobber.timeInWater > 0.8){
      // find nearby fish (simulate): pick random fishSpecies with some chance
      if(Math.random() < 0.003 + (castPower / 100)*0.008){
        fishHooked = pick(fishSpecies);
        reeling = true;
        showMessage(`Fish on! ${fishHooked.name} — hold LMB to reel`);
        beep(1200,0.08,0.06);
      }
    }
  }
}

function reelAttempt(){
  if(!reeling) return;
  // simple success formula: higher castPower => better chance, holding LMB increases chance
  const success = Math.random() < 0.45 + (castPower / 100)*0.45;
  if(success){
    const pts = (fishHooked.points || 10) + Math.round(castPower/10);
    score += pts; updateHUD();
    showMessage(`Caught ${fishHooked.name}! +${pts}`);
    // clean up
    scene.remove(bobber.mesh); bobber = null; fishHooked = null; reeling = false;
  } else {
    showMessage('The fish got away!');
    scene.remove(bobber.mesh); bobber = null; fishHooked = null; reeling = false;
  }
}

/* ---------- HUD and messaging ---------- */
const hud = {
  zone: document.getElementById('zone'),
  timeOfDay: document.getElementById('timeOfDay'),
  health: document.getElementById('health'),
  stamina: document.getElementById('stamina'),
  staminaBar: document.getElementById('staminaBar'),
  score: document.getElementById('score'),
  highScore: document.getElementById('highScore'),
  mode: document.getElementById('mode'),
  weapon: document.getElementById('weapon'),
  rod: document.getElementById('rod'),
  ammo: document.getElementById('ammo'),
  lures: document.getElementById('lures'),
  message: document.getElementById('message')
};
let score = 0; let highScore = Number(localStorage.getItem('hf_highscore') || 0);
hud.highScore.textContent = highScore;

function updateHUD(){
  hud.zone.textContent = isNearWater() ? 'Water' : 'Land';
  hud.timeOfDay.textContent = (dayFactor > 0.45) ? 'Day' : 'Night';
  hud.health.textContent = Math.floor(player.health);
  hud.stamina.textContent = Math.floor(player.stamina);
  hud.staminaBar.style.width = player.stamina + '%';
  hud.score.textContent = score;
  hud.mode.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
  hud.ammo.textContent = ammo;
  hud.lures.textContent = 5;
}

let messageTimeout = null;
function showMessage(msg, ms = 1800){
  const el = document.getElementById('message');
  el.textContent = msg; el.style.display = 'block';
  if(messageTimeout) clearTimeout(messageTimeout);
  messageTimeout = setTimeout(()=> el.style.display = 'none', ms);
}

/* ---------- Time/day cycle ---------- */
let perfTime = 0, dayT = 0, dayFactor = 1;
function updateDayNight(dt){
  dayT += dt / 240; if(dayT > 1) dayT -= 1;
  dayFactor = Math.max(0, Math.cos((dayT - 0.5)*2*Math.PI)*0.5 + 0.5);
  const skyR = Math.floor(30 + dayFactor*130), skyG = Math.floor(60 + dayFactor*150), skyB = Math.floor(90 + dayFactor*180);
  scene.background = new THREE.Color(`rgb(${skyR},${skyG},${skyB})`);
  const angle = dayT * Math.PI * 2;
  sun.position.set(Math.cos(angle)*400, Math.sin(angle)*400, Math.sin(angle*0.6)*400);
}

/* ---------- Minimap (tiny) ---------- */
const mmCanvas = document.createElement('canvas');
mmCanvas.width = 160 * devicePixelRatio; mmCanvas.height = 160 * devicePixelRatio;
mmCanvas.style.width = '160px'; mmCanvas.style.height = '160px';
mmCanvas.style.borderRadius = '8px'; mmCanvas.style.background = 'rgba(0,0,0,0.06)';
document.querySelector('#topRight .panel').appendChild(mmCanvas);
const mmCtx = mmCanvas.getContext('2d');

function drawMinimap(){
  const w = mmCanvas.width, h = mmCanvas.height;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle = '#07202b'; mmCtx.fillRect(0,0,w,h);
  const scale = 0.06; const cx = w/2, cy = h/2;
  // water circle
  mmCtx.fillStyle = '#1e90ff'; mmCtx.beginPath(); mmCtx.arc(cx, cy, WORLD.waterRadius*scale, 0, Math.PI*2); mmCtx.fill();
  // player
  mmCtx.save(); mmCtx.translate(cx,cy); mmCtx.rotate(-yaw);
  mmCtx.fillStyle = '#9fffbf'; mmCtx.beginPath(); mmCtx.moveTo(0,-6); mmCtx.lineTo(4,4); mmCtx.lineTo(-4,4); mmCtx.closePath(); mmCtx.fill(); mmCtx.restore();
  // animals
  for(const a of animals){
    const dx = (a.position.x - player.pos.x) * scale, dz = (a.position.z - player.pos.z) * scale;
    mmCtx.fillStyle = '#f2c08d'; mmCtx.fillRect(cx + dx - 2, cy + dz - 2, 4, 4);
  }
}

/* ---------- Main loop ---------- */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now; perfTime = now;
  // update systems
  updatePlayer(dt);
  updateAnimals(dt);
  updateFish(dt);
  if(castCharging) castPower = clamp(castPower + dt * 56, 0, 100);
  updateBobber(dt);
  if(reeling){} // placeholder for reeling nuance
  updateDayNight(dt);
  updateHUD();
  drawMinimap();
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}

/* small fish update (visual only) */
function updateFish(dt){
  for(const f of fishPool) {
    if(f.state === 'onhook') continue;
    f.dir += (Math.random()-0.5) * 0.3 * dt;
    f.pos.x += Math.cos(f.dir) * f.speed * dt * 10;
    f.pos.z += Math.sin(f.dir) * f.speed * dt * 10;
    f.pos.x = clamp(f.pos.x, -WORLD.size/2 + 4, WORLD.size/2 - 4);
    f.pos.z = clamp(f.pos.z, -WORLD.size/2 + 4, WORLD.size/2 - 4);
    f.depth += Math.sin(perfTime*0.001 + f.pos.x*0.001) * 0.002;
    if(f.mesh) f.mesh.position.set(f.pos.x, f.depth, f.pos.z);
  }
}

/* ---------- Fish pool (spawn around water primarily) ---------- */
const fishSpecies = [
  {name:'Trout', points:20, rarity:5, speed:0.9},
  {name:'Bass', points:30, rarity:6, speed:0.9},
  {name:'Carp', points:15, rarity:7, speed:0.7},
  {name:'Salmon', points:50, rarity:3, speed:1.2},
  {name:'Tuna', points:120, rarity:1, speed:1.7}
];
const fishPool = [];
function spawnFish(count=80){
  for(let i=0;i<count;i++){
    // bias near water: sample polar coordinates around center
    const r = WORLD.waterRadius * (0.2 + Math.random()*1.6);
    const a = Math.random()*Math.PI*2;
    const x = Math.cos(a)*r;
    const z = Math.sin(a)*r;
    const s = pick(fishSpecies);
    const fish = { species: s, pos: new THREE.Vector3(x,0,z), depth: WORLD.waterY - rand(0.4, 3.2), dir: rand(0,Math.PI*2), speed: s.speed*(0.6 + Math.random()*0.9), size: rand(0.5,3), state:'swim', mesh:null };
    const color = (s.points > 100) ? 0xffd27a : (s.points > 40 ? 0xffb27a : 0xa0e2ff);
    const m = new THREE.Mesh(new THREE.SphereGeometry(clamp(0.08 + fish.size*0.03,0.08,1.2), 8,6), new THREE.MeshStandardMaterial({color}));
    m.position.set(x, fish.depth, z); scene.add(m); fish.mesh = m; fishPool.push(fish);
  }
}
spawnFish(100);

/* ---------- Utils: show message ---------- */
function showMessage(txt, ms=1600){ const el=document.getElementById('message'); el.textContent=txt; el.style.display='block'; setTimeout(()=>el.style.display='none', ms); }

/* ---------- initialization ---------- */
updateHUD(); showMessage('Click to lock pointer. WASD move. Near water = fishing, away = hunting.', 4000);
requestAnimationFrame(loop);

/* ---------- Input helpers for reeling (simple) ---------- */
document.addEventListener('keydown', e => {
  if(e.code === 'Space'){ /* jump placeholder */ }
  if(e.code === 'KeyC'){ player.cameraMode = (player.cameraMode + 1) % 3; showMessage(['FP','TP-Short','TP-Mid'][player.cameraMode]); }
  if(e.code === 'KeyR'){ /* change lure placeholder */ showMessage('Switched lure'); beep(660,0.06,0.03); }
  if(e.code === 'KeyB'){ /* board boat placeholder */ showMessage('Board/Leave boat'); }
});

/* ---------- fishing quick-reel on click when reeling ---------- */
window.addEventListener('click', e => {
  if(reeling && pointer.locked){ reelAttempt(); }
});

/* ---------- simple mouse pointer issue debug fallback ---------- */
if(!('requestPointerLock' in document.body)){
  showMessage('Pointer Lock API not supported — use mouse + keyboard but view control may be limited.');
}

</script>
</body>
</html>
