<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mega Open-World Hunt + Fish — Single File</title>
<style>
  :root{--panel:rgba(6,10,20,0.78);--accent:#6fe8ff}
  html,body{height:100%;margin:0;background:#071226;color:#eaf6ff;font-family:Inter,system-ui,Arial,Helvetica,sans-serif;overflow:hidden}
  #game{width:100vw;height:100vh;position:relative}
  canvas{display:block}

  /* HUD */
  .hud{position:absolute;z-index:60;pointer-events:none}
  #topLeft{left:12px;top:12px}
  #topRight{right:12px;top:12px;text-align:right}
  #bottomLeft{left:12px;bottom:12px}
  #bottomRight{right:12px;bottom:12px}
  .panel{background:var(--panel);padding:10px 12px;border-radius:12px;font-size:13px;min-width:240px;box-shadow:0 6px 30px rgba(0,0,0,0.6)}
  .label{color:var(--accent);font-weight:700}
  #crosshair{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:18px;height:18px;pointer-events:none;z-index:70}
  #crosshair:before,#crosshair:after{content:'';position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:2px;height:12px;background:rgba(255,255,255,0.9)}
  #crosshair:before{transform:translate(-50%,-50%) rotate(90deg)}
  .meter{height:10px;background:rgba(255,255,255,0.08);border-radius:6px;overflow:hidden;margin-top:6px}
  .meter>i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#2fa8ff);width:50%}

  #controls{font-size:13px;color:#cde8ff}
  #message{position:absolute;left:50%;top:22%;transform:translateX(-50%);z-index:80;display:none;padding:12px 16px;background:rgba(0,0,0,0.7);border-radius:10px;font-size:17px}
  #minimap{width:160px;height:160px;border-radius:8px;background:rgba(0,0,0,0.06);border:1px solid rgba(255,255,255,0.04)}
  @media(max-width:720px){.panel{min-width:160px;font-size:12px}#minimap{width:120px;height:120px}}
</style>
</head>
<body>
<div id="game"></div>

<!-- HUD -->
<div class="hud" id="topLeft"><div class="panel">
  <div><span class="label">Mega World</span> • Mode: <span id="mode">Explore</span></div>
  <div style="margin-top:6px">Biome: <b id="biome">Lake</b> • Time: <b id="timeOfDay">Day</b></div>
  <div style="margin-top:6px">Health: <span id="health">100</span> • Stamina: <span id="stamina">100</span></div>
  <div style="margin-top:6px">Weapon: <span id="weapon">None</span> • Rod: <span id="rod">Basic</span></div>
  <div class="meter"><i id="staminaBar" style="width:100%"></i></div>
</div></div>

<div class="hud" id="topRight"><div class="panel">
  <div>Score: <b id="score">0</b></div>
  <div style="margin-top:8px">High Score: <b id="highScore">0</b></div>
  <div style="margin-top:8px">Lures: <span id="lures">5</span> • Ammo: <span id="ammo">10</span></div>
</div></div>

<div class="hud" id="bottomLeft"><div class="panel" id="controls">
  Controls: Click to lock pointer • WASD move • Mouse look • Shift sprint • Space jump <br>
  Left Click: Fire / Cast / Interact • Hold LMB to charge cast • R: switch rod/lure • B: board/leave boat • C: camera • M: toggle minimap
</div></div>

<div class="hud" id="bottomRight"><div class="panel" style="display:flex;flex-direction:column;align-items:center;gap:8px">
  <canvas id="minimap"></canvas>
  <div style="font-size:12px;color:#cde8ff">Minimap</div>
</div></div>

<div id="crosshair"></div>
<div id="message"></div>

<!-- Three.js CDN -->
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
/* -------------------------------------------
   Mega Open-World Hunt + Fish — Single File
   - Combined hunting & fishing gameplay
   - Max detail, but optimized for MacBook Air
   - Single-file, GitHub Pages compatible
   ------------------------------------------- */

/* -------------------------
   Config & Helpers
   ------------------------- */
const CONFIG = {
  worldSize: 1200,
  waterLevel: -1.5,
  maxAnimals: 28,      // tuned for performance
  maxFish: 130,
  dayLengthSec: 300,
  detailScale: 1.0     // set lower for weaker machines
};
function rand(a,b){return a + Math.random()*(b-a)}
function clamp(v,a,b){return Math.max(a,Math.min(b,v))}
function pick(arr){return arr[Math.floor(Math.random()*arr.length)]}
function format(n){return Math.round(n*100)/100}

/* -------------------------
   Audio (WebAudio small cues)
   ------------------------- */
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function sfx(freq=440,dur=0.08,vol=0.04,type='sine'){
  const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq; g.gain.value = vol;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime + dur);
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + dur);
}

/* -------------------------
   Scene & Renderer
   ------------------------- */
const container = document.getElementById('game');
const scene = new THREE.Scene();
scene.fog = new THREE.FogExp2(0x90b8ff, 0.00055);

const camera = new THREE.PerspectiveCamera(68, innerWidth/innerHeight, 0.1, 4000);
camera.up.set(0,1,0);

const renderer = new THREE.WebGLRenderer({ antialias:true });
renderer.setSize(innerWidth, innerHeight);
renderer.shadowMap.enabled = true;
container.appendChild(renderer.domElement);

/* Lights */
const ambient = new THREE.AmbientLight(0x89b9ff, 0.4);
scene.add(ambient);
const sun = new THREE.DirectionalLight(0xfff2c9, 0.9);
sun.position.set(200,400,-200);
sun.castShadow = true;
sun.shadow.mapSize.set(2048,2048);
scene.add(sun);

/* -------------------------
   Terrain & Water
   ------------------------- */
const terrainGeo = new THREE.PlaneGeometry(CONFIG.worldSize, CONFIG.worldSize, 96, 96);
terrainGeo.rotateX(-Math.PI/2);
for(let i=0;i<terrainGeo.attributes.position.count;i++){
  const x = terrainGeo.attributes.position.getX(i);
  const z = terrainGeo.attributes.position.getZ(i);
  const d = Math.hypot(x,z);
  let h = Math.sin(x*0.002)*6 + Math.cos(z*0.002)*6 + Math.sin((x+z)*0.001)*3;
  h *= clamp(1 - (d / (CONFIG.worldSize/1.5)), 0.08, 1);
  terrainGeo.attributes.position.setY(i, h - 3);
}
terrainGeo.computeVertexNormals();
const terrainMat = new THREE.MeshStandardMaterial({ color:0x3b8a3b, roughness:1 });
const terrain = new THREE.Mesh(terrainGeo, terrainMat);
terrain.receiveShadow = true;
scene.add(terrain);

/* Water plane (simple) */
const waterMat = new THREE.MeshStandardMaterial({ color:0x1e88ff, transparent:true, opacity:0.86, roughness:0.4 });
const water = new THREE.Mesh(new THREE.PlaneGeometry(CONFIG.worldSize*2, CONFIG.worldSize*2), waterMat);
water.rotation.x = -Math.PI/2; water.position.y = CONFIG.waterLevel;
scene.add(water);

/* -------------------------
   Decorations (low poly)
   ------------------------- */
const decor = new THREE.Group(); scene.add(decor);
function createDecor(){
  const count = Math.floor(280 * CONFIG.detailScale);
  for(let i=0;i<count;i++){
    const x = rand(-CONFIG.worldSize/2, CONFIG.worldSize/2);
    const z = rand(-CONFIG.worldSize/2, CONFIG.worldSize/2);
    const h = getHeightAt(x,z);
    if(h < CONFIG.waterLevel - 1) continue;
    if(Math.random() < 0.6){
      // tree
      const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.18,0.28,2), new THREE.MeshStandardMaterial({color:0x7b4c2b}));
      trunk.position.set(x, h + 1, z);
      const leaves = new THREE.Mesh(new THREE.ConeGeometry(1.4 + Math.random()*0.6, 3 + Math.random()*1.4, 6), new THREE.MeshStandardMaterial({color:0x134f2a}));
      leaves.position.set(x, h + 3.1, z);
      trunk.castShadow = true; leaves.castShadow = true;
      decor.add(trunk); decor.add(leaves);
    } else {
      // rock / reed
      if(Math.random() < 0.55){
        const r = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,1.4), new THREE.MeshStandardMaterial({color:0x345c2f}));
        r.position.set(x,h+0.7,z); decor.add(r);
      } else {
        const rock = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6 + Math.random()*1.3), new THREE.MeshStandardMaterial({color:0x666666}));
        rock.position.set(x,h+0.4,z); rock.rotation.set(Math.random(),Math.random(),Math.random()); decor.add(rock);
      }
    }
  }
}
createDecor();

/* Height sampling helper (same function as terrain builder approximation) */
function getHeightAt(x,z){
  let h = Math.sin(x*0.002)*6 + Math.cos(z*0.002)*6 + Math.sin((x+z)*0.001)*3;
  const d = Math.hypot(x,z);
  h *= clamp(1 - (d / (CONFIG.worldSize/1.5)), 0.08, 1);
  return h - 3;
}

/* -------------------------
   Player & Controls
   ------------------------- */
const player = {
  pos: new THREE.Vector3(30,0,30),
  height: 1.85,
  stamina: 100,
  health: 100,
  cameraMode: 0, // 0 FP, 1 short TP, 2 mid TP
  inBoat: false,
  boat: null
};

camera.position.copy(player.pos).add(new THREE.Vector3(0, player.height + 1.4, 6));
camera.lookAt(player.pos.x, player.pos.y + 1.4, player.pos.z);

let yaw = 0, pitch = 0;
const keys = {};
window.addEventListener('keydown', e => keys[e.code] = true);
window.addEventListener('keyup', e => keys[e.code] = false);
document.body.addEventListener('click', ()=>{ if(audioCtx.state==='suspended') audioCtx.resume(); document.body.requestPointerLock && document.body.requestPointerLock(); });

document.addEventListener('mousemove', e => {
  if(document.pointerLockElement === document.body){
    yaw -= e.movementX * 0.0022;
    pitch -= e.movementY * 0.0022;
    pitch = clamp(pitch, -Math.PI/2 + 0.05, Math.PI/2 - 0.05);
  }
});

function updatePlayer(dt){
  const forward = new THREE.Vector3(Math.sin(yaw),0,Math.cos(yaw));
  const right = new THREE.Vector3(forward.z,0,-forward.x);
  const move = new THREE.Vector3();
  if(keys['KeyW']) move.add(forward);
  if(keys['KeyS']) move.sub(forward);
  if(keys['KeyA']) move.sub(right);
  if(keys['KeyD']) move.add(right);
  if(move.lengthSq()>0) move.normalize();

  let speed = player.inBoat ? 5 : (keys['ShiftLeft'] ? 5 : 2.2);
  // stamina drain if sprinting
  if(!player.inBoat && keys['ShiftLeft'] && player.stamina > 0){
    player.stamina = clamp(player.stamina - dt*14, 0, 100);
  } else {
    player.stamina = clamp(player.stamina + dt*6, 0, 100);
  }

  const deltaMove = move.multiplyScalar(speed * dt * 4);
  player.pos.add(deltaMove);

  // clamp world bounds
  player.pos.x = clamp(player.pos.x, -CONFIG.worldSize/2 + 6, CONFIG.worldSize/2 - 6);
  player.pos.z = clamp(player.pos.z, -CONFIG.worldSize/2 + 6, CONFIG.worldSize/2 - 6);
  player.pos.y = getHeightAt(player.pos.x, player.pos.z) + player.height;

  // camera
  const camBase = player.pos.clone().add(new THREE.Vector3(0, player.height + 0.6, 0));
  const behind = new THREE.Vector3(0, 0, (player.cameraMode === 0 ? 0 : (player.cameraMode===1?6:12))).applyEuler(new THREE.Euler(0, yaw, 0));
  camera.position.copy(camBase).add(behind);
  camera.lookAt(camBase);
}

/* -------------------------
   Boats (simple)
   ------------------------- */
const boats = [];
function spawnBoat(x,z){
  const hull = new THREE.Mesh(new THREE.BoxGeometry(3,0.6,1.6), new THREE.MeshStandardMaterial({color:0x9e5a3c}));
  hull.position.set(x, getHeightAt(x,z) + 0.2, z);
  hull.castShadow = true;
  scene.add(hull);
  boats.push({mesh:hull, pos:new THREE.Vector3(x,hull.position.y,z), dir:rand(0,Math.PI*2), speed:0});
}
// spawn near waterline a few boats
for(let i=0;i<6;i++){
  spawnBoat(rand(-CONFIG.worldSize*0.25, CONFIG.worldSize*0.25), rand(-CONFIG.worldSize*0.25, CONFIG.worldSize*0.25));
}
function updateBoats(dt, t){
  for(const b of boats){
    b.dir += (Math.random()-0.5) * 0.01;
    b.speed = clamp(0.2 + Math.sin(t*0.0005 + b.pos.x*0.001) * 0.6, 0.05, 1.1);
    b.pos.x += Math.sin(b.dir) * b.speed * dt*6;
    b.pos.z += Math.cos(b.dir) * b.speed * dt*6;
    b.mesh.position.x = b.pos.x; b.mesh.position.z = b.pos.z;
    b.mesh.position.y = getHeightAt(b.pos.x, b.pos.z) + 0.2;
  }
}

/* -------------------------
   Animal (Hunt) system
   ------------------------- */
const animalSpecies = [
  {name:'Deer', color:0xc4a176, size:1.6, speed:2.6, hp:60, points:60, rarity:0.7},
  {name:'Boar', color:0x7b5e4a, size:1.3, speed:2.2, hp:110, points:40, rarity:0.9},
  {name:'Rabbit', color:0xffffff, size:0.5, speed:3.2, hp:12, points:12, rarity:1.5}
];

const animals = [];
function spawnAnimals(n = Math.floor(CONFIG.maxAnimals * CONFIG.detailScale)){
  for(let i=0;i<n;i++){
    const s = pick(animalSpecies);
    let x,z, h;
    do {
      x = rand(-CONFIG.worldSize/2, CONFIG.worldSize/2);
      z = rand(-CONFIG.worldSize/2, CONFIG.worldSize/2);
      h = getHeightAt(x,z);
    } while(h < CONFIG.waterLevel + 1 || Math.hypot(x,z) < 40);
    const mesh = new THREE.Group();
    const body = new THREE.Mesh(new THREE.BoxGeometry(s.size*1.0, s.size*0.6, s.size*0.6), new THREE.MeshStandardMaterial({color:s.color}));
    body.position.set(0,s.size*0.4,0);
    mesh.add(body);
    mesh.position.set(x,h+0.2,z);
    mesh.userData = {species:s, state:'idle', target: null, hp: s.hp};
    animals.push(mesh);
    scene.add(mesh);
  }
}
spawnAnimals();

function updateAnimals(dt){
  for(const a of animals){
    const ud = a.userData;
    if(ud.state === 'dead') continue;
    // simple wandering
    if(!ud.target || Math.random() < 0.008) {
      ud.target = new THREE.Vector3(a.position.x + rand(-20,20), 0, a.position.z + rand(-20,20));
      ud.target.y = getHeightAt(ud.target.x, ud.target.z) + 1.0;
    }
    const dir = new THREE.Vector3().subVectors(ud.target, a.position);
    if(dir.length() > 1.2) {
      dir.normalize();
      a.position.addScaledVector(dir, ud.species.speed * dt * (ud.state === 'alert' ? 1.8 : 0.75));
      a.position.y = getHeightAt(a.position.x, a.position.z) + 0.2;
      a.lookAt(ud.target.x, a.position.y, ud.target.z);
    } else {
      if(Math.random() < 0.02) ud.target = null;
    }
    // detection: if player makes noise nearby (we model simple: sprinting noise)
    const d = a.position.distanceTo(player.pos);
    const playerNoise = (keys['ShiftLeft'] && (Math.abs(player.pos.x - a.position.x) > 0 || Math.abs(player.pos.z - a.position.z) > 0)) ? 1.0 : 0.15;
    if(d < 45 * (1 + playerNoise) && Math.random() < 0.003 * (1 + playerNoise*6)) {
      ud.state = 'alert';
      // flee away from player
      const away = new THREE.Vector3().subVectors(a.position, player.pos).normalize();
      ud.target = a.position.clone().add(away.multiplyScalar(40));
    }
  }
}

/* -------------------------
   Hunting weapons (simple hitscan rifle)
   ------------------------- */
let currentWeapon = 'rifle';
let ammo = 12;
const weaponCfg = {rifle:{damage:60,range:450,fireRate:0.28,spread:0.006}};

let lastFire = -999;
function fireWeapon(){
  const now = performance.now()/1000;
  if(now - lastFire < weaponCfg.rifle.fireRate) return;
  if(ammo <= 0){ sfx(140,0.14,0.02,'triangle'); return; }
  lastFire = now; ammo--; document.getElementById('ammo').textContent = ammo;
  // hitscan: check animals
  const origin = camera.position.clone();
  const dir = new THREE.Vector3(0,0,-1).applyEuler(camera.rotation).normalize();
  // add spread
  dir.x += (Math.random()*2-1) * weaponCfg.rifle.spread;
  dir.y += (Math.random()*2-1) * weaponCfg.rifle.spread;
  dir.normalize();
  // check animals by simple distance to ray
  let hit = null, best = 1e9;
  for(const a of animals){
    if(a.userData.state === 'dead') continue;
    const toA = new THREE.Vector3().subVectors(a.position, origin);
    const proj = toA.dot(dir);
    if(proj > 0 && proj < weaponCfg.rifle.range){
      const closest = origin.clone().add(dir.clone().multiplyScalar(proj));
      const d = closest.distanceTo(a.position);
      if(d < 2.2 && proj < best){ best = proj; hit = a; }
    }
  }
  if(hit){
    sfx(1200, 0.06, 0.05, 'square');
    hit.userData.hp -= weaponCfg.rifle.damage;
    if(hit.userData.hp <= 0){
      hit.userData.state = 'dead';
      // drop carcass (simple)
      scene.remove(hit);
      const idx = animals.indexOf(hit); if(idx>=0) animals.splice(idx,1);
      const pts = hit.userData.species.points;
      score += pts; updateHUD();
      showMessage(`Down: ${hit.userData.species.name} +${pts}`);
      // spawn replacement later
      setTimeout(()=> spawnAnimals(1), 5000);
    } else {
      hit.userData.state = 'alert';
      showMessage(`${hit.userData.species.name} wounded!`);
    }
  } else {
    // miss => tracer (very short)
    sfx(900, 0.06, 0.04, 'sine');
  }
}

/* -------------------------
   Fish system (detailed)
   ------------------------- */
const fishSpecies = [
  {name:'Brown Trout', biomes:['Lake','River'], weight:[0.6,3], rarity:5, fight:20, speed:0.8, points:25},
  {name:'Bass', biomes:['Lake','Marsh'], weight:[0.8,5], rarity:6, fight:28, speed:0.9, points:35},
  {name:'Pike', biomes:['Marsh','Lake'], weight:[1.2,8], rarity:4, fight:40, speed:1.2, points:50},
  {name:'Catfish', biomes:['River','Marsh'], weight:[1.5,10], rarity:3, fight:45, speed:0.6, points:45},
  {name:'Salmon', biomes:['River','Ocean'], weight:[2,12], rarity:2, fight:60, speed:1.3, points:70},
  {name:'Tuna', biomes:['Ocean'], weight:[10,40], rarity:1, fight:120, speed:1.8, points:150},
  {name:'Mackerel', biomes:['Ocean'], weight:[0.5,2], rarity:8, fight:12, speed:1.1, points:15}
];

const fishPool = [];
function spawnFish(count = Math.floor(CONFIG.maxFish * CONFIG.detailScale)){
  for(let i=0;i<count;i++){
    spawnSingleFish(rand(-CONFIG.worldSize/2, CONFIG.worldSize/2), rand(-CONFIG.worldSize/2, CONFIG.worldSize/2));
  }
}
function spawnSingleFish(x,z){
  const b = biomeAt(x,z);
  const candidates = fishSpecies.filter(s => s.biomes.includes(b));
  if(candidates.length === 0) return;
  const s = pick(candidates);
  const fish = {
    species: s,
    pos: new THREE.Vector3(x,0,z),
    depth: CONFIG.waterLevel - rand(0.2, 3.5),
    dir: rand(0,Math.PI*2),
    speed: s.speed * (0.6 + Math.random()*0.9),
    size: rand(s.weight[0], s.weight[1]),
    state: 'swim',
    mesh: null
  };
  const color = s.points > 100 ? 0xffd27a : (s.points > 40 ? 0xffb27a : 0xa0e2ff);
  const m = new THREE.Mesh(new THREE.SphereGeometry(clamp(0.08 + fish.size*0.03, 0.08, 1.2), 8, 6), new THREE.MeshStandardMaterial({color}));
  m.position.set(x, fish.depth, z);
  scene.add(m); fish.mesh = m; fishPool.push(fish);
}
spawnFish();

/* Simple biome mapping */
function biomeAt(x,z){
  if(z > CONFIG.worldSize*0.18) return 'Ocean';
  if(z < -CONFIG.worldSize*0.18) return 'River';
  if(x > CONFIG.worldSize*0.25) return 'Marsh';
  return 'Lake';
}

/* Fish behavior update */
function updateFish(dt){
  for(const f of fishPool){
    if(f.state === 'onhook') continue;
    f.dir += (Math.random()-0.5) * 0.4 * dt * 5;
    f.pos.x += Math.cos(f.dir) * f.speed * dt * 10;
    f.pos.z += Math.sin(f.dir) * f.speed * dt * 10;
    f.pos.x = clamp(f.pos.x, -CONFIG.worldSize/2 + 3, CONFIG.worldSize/2 - 3);
    f.pos.z = clamp(f.pos.z, -CONFIG.worldSize/2 + 3, CONFIG.worldSize/2 - 3);
    f.depth += Math.sin(perfTime*0.001 + f.pos.x*0.001) * 0.002;
    if(f.mesh) f.mesh.position.set(f.pos.x, f.depth, f.pos.z);
    if(Math.random() < 0.005) f.dir += (Math.random()-0.5);
  }
}

/* -------------------------
   Casting & Reeling logic
   ------------------------- */
const lures = [
  {name:'Standard',castMult:1.0,attract:1.0},
  {name:'Heavy',castMult:1.4,attract:0.8},
  {name:'Feather',castMult:0.8,attract:1.5},
  {name:'Deep',castMult:1.2,attract:1.2}
];
let currentLureIndex = 0;
let castCharging = false;
let castPower = 0;
let bobber = null;
let hookedFish = null;
let reelingState = null;
let mouseDown = false;

document.addEventListener('mousedown', e => {
  if(e.button === 0){ mouseDown = true; if(!bobber && !reelingState) startCharge(); else if(reelingState) reelingState.playerReeling=true; }
});
document.addEventListener('mouseup', e => {
  if(e.button === 0){ mouseDown = false; if(castCharging) releaseCast(); if(reelingState) reelingState.playerReeling=false; }
});
document.addEventListener('keydown', e => {
  if(e.code === 'KeyR'){ currentLureIndex = (currentLureIndex + 1) % lures.length; sfx(660,0.06,0.03); }
  if(e.code === 'KeyB') toggleBoardBoat();
  if(e.code === 'KeyC') player.cameraMode = (player.cameraMode + 1) % 3;
  if(e.code === 'KeyM') document.getElementById('minimap').parentElement.style.display = document.getElementById('minimap').parentElement.style.display === 'none' ? 'block' : 'none';
});

function startCharge(){ if(bobber || reelingState) return; castCharging = true; castPower = 0; }
function releaseCast(){
  castCharging = false;
  const dir = new THREE.Vector3(0, 0, -1).applyEuler(camera.rotation).normalize();
  const base = 14 * (0.35 + 1.65 * (castPower / 100));
  const vel = dir.clone().multiplyScalar(base * lures[currentLureIndex].castMult);
  // spawn bobber near camera
  const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.18, 8, 8), new THREE.MeshStandardMaterial({color:0xff4d6d}));
  sphere.position.copy(camera.position).add(new THREE.Vector3(0, -0.2, 0)).add(dir.clone().multiplyScalar(1.4));
  scene.add(sphere);
  bobber = {mesh:sphere, vel, timeInWater:0, landed:false};
  sfx(880,0.06,0.04);
}
function updateBobber(dt){
  if(!bobber) return;
  if(!bobber.landed){
    bobber.vel.y -= 9.8 * dt * 0.65;
    bobber.mesh.position.add(bobber.vel.clone().multiplyScalar(dt));
    if(bobber.mesh.position.y <= CONFIG.waterLevel + 0.05){
      bobber.landed = true; bobber.mesh.position.y = CONFIG.waterLevel + 0.05; bobber.timeInWater = 0; sfx(420,0.08,0.03);
    }
  } else {
    bobber.timeInWater += dt;
    bobber.mesh.position.x += Math.sin(perfTime*0.001) * 0.008;
    bobber.mesh.position.z += Math.cos(perfTime*0.001) * 0.008;
    if(!hookedFish && bobber.timeInWater > 0.8){
      const bpos = new THREE.Vector3(bobber.mesh.position.x,0,bobber.mesh.position.z);
      const candidates = fishPool.filter(f => {
        const d = Math.hypot(f.pos.x - bpos.x, f.pos.z - bpos.z);
        return d < (18 * lures[currentLureIndex].attract) && f.state === 'swim';
      });
      if(candidates.length > 0){
        for(const f of candidates){
          const chance = 0.0008 * (1 + lures[currentLureIndex].attract) * (2 / (f.species.rarity || 1)) * (1 + bobber.timeInWater/4);
          if(Math.random() < chance){
            // fish bites
            hookedFish = f; f.state = 'onhook';
            sfx(1200,0.08,0.06); showMessage(`Bite! ${f.species.name} on hook — reel!`); startReel(f);
            break;
          }
        }
      }
    }
  }
}

/* Reeling mini-game simplified and optimized for responsiveness */
function startReel(fish){
  reelingState = {
    fish,
    progress:0,
    fishEnergy: fish.species.fight * (0.8 + Math.random()*0.9),
    playerEnergy: 80,
    tension: 0,
    playerReeling: false
  };
}
function updateReeling(dt){
  if(!reelingState) return;
  const st = reelingState;
  // fish pulls
  const fishPull = (Math.random() * st.fishEnergy * 0.01);
  const playerPull = st.playerReeling ? (1.8 + (st.playerEnergy/100)) : 0;
  st.tension += (fishPull*0.02 - playerPull*0.02) * dt * 6;
  st.tension = clamp(st.tension, 0, 1.6);
  if(st.playerReeling){
    st.progress = clamp(st.progress + (playerPull*6 - fishPull*0.6) * dt * 6, 0, 100);
    st.playerEnergy = clamp(st.playerEnergy - dt*12, 0, 200);
  } else {
    st.progress = clamp(st.progress - fishPull * dt * 8, 0, 100);
    st.playerEnergy = clamp(st.playerEnergy + dt*6, 0, 200);
  }
  // failure conditions
  if(st.tension > 1.1 && Math.random() < (st.tension - 1.0) * dt * 6){
    // snap
    showMessage('Line snapped!'); sfx(120,0.12,0.02,'triangle'); endReel(false, true);
    return;
  }
  if(st.playerEnergy <= 0){
    showMessage('Too tired — fish escaped'); endReel(false, false); return;
  }
  if(st.progress >= 100){
    endReel(true, false); return;
  }
}
function endReel(success, broken){
  if(!reelingState) return;
  const f = reelingState.fish;
  if(success){
    const pts = Math.round(f.size * 10 + f.species.points);
    score += pts; updateHUD();
    showMessage(`Caught ${f.species.name} (${format(f.size)} kg) +${pts}`);
    // remove fish entity
    scene.remove(f.mesh);
    const idx = fishPool.indexOf(f); if(idx>=0) fishPool.splice(idx,1);
    setTimeout(()=> spawnSingleFish(rand(-CONFIG.worldSize/2, CONFIG.worldSize/2), rand(-CONFIG.worldSize/2, CONFIG.worldSize/2)), 2500);
  } else {
    if(broken) showMessage('Line snapped — fish freed');
    else showMessage('Fish escaped');
    f.state = 'swim';
  }
  // cleanup bobber
  if(bobber){ scene.remove(bobber.mesh); bobber = null; }
  hookedFish = null; reelingState = null;
}

/* -------------------------
   HUD & Minimap
   ------------------------- */
const hud = {
  biome: document.getElementById('biome'),
  timeOfDay: document.getElementById('timeOfDay'),
  health: document.getElementById('health'),
  stamina: document.getElementById('stamina'),
  staminaBar: document.getElementById('staminaBar'),
  score: document.getElementById('score'),
  highScore: document.getElementById('highScore'),
  mode: document.getElementById('mode'),
  weapon: document.getElementById('weapon'),
  rod: document.getElementById('rod'),
  ammo: document.getElementById('ammo'),
  lures: document.getElementById('lures'),
  message: document.getElementById('message')
};
let score = 0, highScore = Number(localStorage.getItem('mega_highscore') || 0);
hud.highScore.textContent = highScore;
hud.lures.textContent = 5; hud.ammo.textContent = ammo;

function updateHUD(){
  hud.biome.textContent = biomeAt(player.pos.x, player.pos.z);
  hud.timeOfDay.textContent = (dayFactor > 0.45) ? 'Day' : 'Night';
  hud.health.textContent = Math.floor(player.health);
  hud.stamina.textContent = Math.floor(player.stamina);
  hud.staminaBar.style.width = player.stamina + '%';
  hud.score.textContent = score;
  hud.mode.textContent = (bobber || reelingState) ? 'Fishing' : (currentWeapon ? 'Hunting' : 'Explore');
  hud.weapon.textContent = currentWeapon;
  hud.rod.textContent = lures[currentLureIndex].name;
  hud.ammo.textContent = ammo;
  hud.lures.textContent = Math.max(0,5); // placeholder inventory
}
function showMessage(t, dur=2000){
  hud.message.textContent = t; hud.message.style.display = 'block';
  setTimeout(()=> { hud.message.style.display = 'none'; }, dur);
}

/* Minimap */
const mmCanvas = document.getElementById('minimap'); mmCanvas.width = mmCanvas.clientWidth * devicePixelRatio; mmCanvas.height = mmCanvas.clientHeight * devicePixelRatio;
const mmCtx = mmCanvas.getContext('2d');
function drawMinimap(){
  const w = mmCanvas.width, h = mmCanvas.height;
  mmCtx.clearRect(0,0,w,h);
  mmCtx.fillStyle = '#051827'; mmCtx.fillRect(0,0,w,h);
  const scale = 0.06; const cx = w/2, cy = h/2;
  // fish
  for(const f of fishPool){
    const dx = (f.pos.x - player.pos.x) * scale, dz = (f.pos.z - player.pos.z) * scale;
    mmCtx.fillStyle = f.species.points > 100 ? '#ffd27a' : '#7fe0ff';
    mmCtx.beginPath(); mmCtx.arc(cx + dx, cy + dz, 2, 0, Math.PI*2); mmCtx.fill();
  }
  // animals
  for(const a of animals){
    const dx = (a.position.x - player.pos.x) * scale, dz = (a.position.z - player.pos.z) * scale;
    mmCtx.fillStyle = '#f2c08d'; mmCtx.fillRect(cx + dx - 2, cy + dz - 2, 4, 4);
  }
  // boats
  for(const b of boats){
    const dx = (b.pos.x - player.pos.x) * scale, dz = (b.pos.z - player.pos.z) * scale;
    mmCtx.fillStyle = '#c07b50'; mmCtx.fillRect(cx + dx - 2, cy + dz - 2, 4, 4);
  }
  // player
  mmCtx.save(); mmCtx.translate(cx, cy); mmCtx.rotate(-yaw); mmCtx.fillStyle = '#9fffbf';
  mmCtx.beginPath(); mmCtx.moveTo(0,-6); mmCtx.lineTo(4,4); mmCtx.lineTo(-4,4); mmCtx.closePath(); mmCtx.fill(); mmCtx.restore();
}

/* -------------------------
   Time, weather
   ------------------------- */
let perfTime = 0, dayT = 0, dayFactor = 1;
let weather = { rain:false, wind: rand(-1,1) };
function updateDayNight(dt){
  dayT += dt / CONFIG.dayLengthSec;
  if(dayT > 1) dayT -= 1;
  dayFactor = Math.max(0, Math.cos((dayT - 0.5)*2*Math.PI) * 0.5 + 0.5);
  const skyR = Math.floor(20 + dayFactor*120), skyG = Math.floor(40 + dayFactor*150), skyB = Math.floor(70 + dayFactor*200);
  scene.background = new THREE.Color(`rgb(${skyR},${skyG},${skyB})`);
  const angle = dayT * Math.PI * 2;
  sun.position.set(Math.cos(angle)*400, Math.sin(angle)*400, Math.sin(angle*0.6)*400);
}

/* -------------------------
   Performance friendly loop
   ------------------------- */
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000);
  last = now; perfTime = now;
  // update
  updatePlayer(dt);
  updateBoats(dt);
  updateAnimals(dt);
  updateFish(dt);
  updateBobber(dt);
  if(reelingState) updateReeling(dt);
  updateDayNight(dt);
  updateHUD();
  drawMinimap();

  // cast charging UI
  if(castCharging){ castPower = clamp(castPower + dt * 56, 0, 100); } else castPower = clamp(castPower - dt * 24, 0, 100);

  // render
  renderer.render(scene, camera);
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

/* -------------------------
   Helpers & cleanup
   ------------------------- */
window.addEventListener('resize', ()=> { camera.aspect = innerWidth / innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight); });

window.addEventListener('beforeunload', ()=> { if(score > highScore) localStorage.setItem('mega_highscore', score); });

/* Utilities for brevity */
function updateFish(dt){ /* reuse earlier function to animate fish: see above */ 
  // inlined for performance: move fish positions toward their dir
  for(const f of fishPool){
    if(f.state === 'onhook') continue;
    f.dir += (Math.random()-0.5) * 0.4 * dt * 4;
    f.pos.x += Math.cos(f.dir) * f.speed * dt * 10;
    f.pos.z += Math.sin(f.dir) * f.speed * dt * 10;
    f.pos.x = clamp(f.pos.x, -CONFIG.worldSize/2 + 3, CONFIG.worldSize/2 - 3);
    f.pos.z = clamp(f.pos.z, -CONFIG.worldSize/2 + 3, CONFIG.worldSize/2 - 3);
    f.depth += Math.sin(perfTime*0.0009 + f.pos.x*0.0012) * 0.002;
    if(f.mesh) f.mesh.position.set(f.pos.x, f.depth, f.pos.z);
    if(Math.random() < 0.005) f.dir += (Math.random()-0.5) * 0.8;
  }
}

/* -------------------------
   Initial HUD update
   ------------------------- */
updateHUD();
showMessage('Welcome — explore lakes, rivers and forests. Click to lock pointer and play.', 3500);

</script>
</body>
</html>
